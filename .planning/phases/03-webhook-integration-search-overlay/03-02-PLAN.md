---
phase: 03-webhook-integration-search-overlay
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/content/upwork-content.js
  - src/content/search-scraper.js
autonomous: false

must_haves:
  truths:
    - "On search page load, colored circle icons appear next to each job title within a few seconds"
    - "Green circle = n8n returned 'match', red circle = 'no_match', blue circle = 'applied'"
    - "If n8n is unavailable or returns no status, no icons appear and no errors are thrown"
    - "A 'Scrape Job' button appears on job detail pages (INJC-02)"
    - "Clicking the scrape button on a detail page triggers a PUSH_JOBS message with the current job's data"
  artifacts:
    - path: "src/content/upwork-content.js"
      provides: "Search page init: collects job IDs, sends GET_MATCH_STATUS to service worker, injects icons on response"
      contains: "GET_MATCH_STATUS"
    - path: "src/content/upwork-content.js"
      provides: "Detail page init: injects scrape button, sends PUSH_JOBS on click"
      contains: "scrape-btn"
    - path: "src/background/service-worker.js"
      provides: "GET_MATCH_STATUS handler: POSTs job IDs to n8n match endpoint, returns status map to content script"
      contains: "GET_MATCH_STATUS"
  key_links:
    - from: "src/content/upwork-content.js"
      to: "src/background/service-worker.js"
      via: "chrome.runtime.sendMessage"
      pattern: "GET_MATCH_STATUS"
    - from: "src/background/service-worker.js"
      to: "n8n match endpoint"
      via: "fetch POST to webhookUrl + '/match' or matchWebhookUrl from storage"
      pattern: "fetch.*match"
    - from: "src/content/upwork-content.js"
      to: "Upwork job card DOM"
      via: "querySelector / appendChild"
      pattern: "job-status-icon"
---

<objective>
Inject colored match status icons into Upwork search result job cards, and add a scrape button to job detail pages.

On search page load: content script collects all visible job IDs, sends them to the service worker, which POSTs to n8n's match endpoint, then relays the status map back. Content script injects a small colored circle span next to each job title based on the map.

On detail page: content script injects a "Scrape Job" button. Clicking it sends PUSH_JOBS (using the job data already scraped by detail-scraper.js from Phase 2) to the service worker.

Purpose: Close INJC-01 (color icons on search) and INJC-02 (scrape button on detail).
Output: Updated src/content/upwork-content.js with icon injection and button injection logic; updated src/background/service-worker.js with GET_MATCH_STATUS handler.
</objective>

<execution_context>
@C:/Users/Glorvax/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Glorvax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/PROJECT.md
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/ROADMAP.md
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/STATE.md
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/phases/03-webhook-integration-search-overlay/03-01-SUMMARY.md

## Phase 2 scraper outputs

search-scraper.js: extracts job cards from DOM, returns array of { job_id, title, url } per card
detail-scraper.js: extracts full job object from detail page DOM, returns single job object with all 15 reference fields
upwork-content.js: router — detects current page type (search vs detail) and calls appropriate scraper

## n8n match endpoint contract (WEHK-02)

Request: POST to match webhook URL, body: { job_ids: ["id1", "id2", ...] }
Response: { "id1": "match", "id2": "no_match", "id3": "applied" }
Status values: "match" | "no_match" | "applied" — anything else treated as unknown (no icon)

The match webhook URL is stored separately from the push webhook URL, OR appended as /match to the base URL. Use a separate chrome.storage.local key: matchWebhookUrl. If not set, fall back to webhookUrl + '/match'.

## Icon design

Inject a <span> element with class "upwork-ext-status-icon" directly after the job title link element.
Styles (inline, no external CSS to avoid CSP issues):
- match: background-color #22c55e (green), border-radius 50%, width 10px, height 10px, display inline-block, margin-left 6px, vertical-align middle
- no_match: background-color #ef4444 (red), same shape
- applied: background-color #3b82f6 (blue), same shape

Do not inject if an icon already exists on that card (check for existing .upwork-ext-status-icon before inserting — handles re-runs on SPA navigation).

## Upwork DOM selectors (approximate — executor must verify on live page)

Search results page: job cards are likely article elements or divs with data-job-id attribute, or the job ID is embedded in the job title link href (e.g., /jobs/~01234abcde). Extract job IDs from title link hrefs using regex /jobs\/~([a-z0-9]+)/i or from data attributes.

Detail page: job ID is in the URL path. Use window.location.pathname.match(/\/jobs\/~([a-z0-9]+)/i) to extract it.

Detail page scrape button: inject as a <button id="upwork-ext-scrape-btn"> in a visible location near the job header (e.g., after the job title h1 or in the apply section). Style inline: background #14a800 (Upwork green), color white, padding 8px 16px, border none, border-radius 4px, cursor pointer, font-size 14px.

## SPA navigation

Upwork is a React SPA. The content script runs on page load but navigation between pages does not trigger a full reload. Use a MutationObserver on document.body to detect URL changes and re-run the appropriate init function when the path changes.
</context>

<tasks>

<task type="auto">
  <name>Task 1: GET_MATCH_STATUS handler in service worker + icon injection in content script</name>
  <files>src/background/service-worker.js, src/content/upwork-content.js</files>
  <action>
TWO files in one task because the message round-trip (content -> SW -> n8n -> SW -> content) must be implemented together.

**src/background/service-worker.js — add GET_MATCH_STATUS case:**

Add to the existing chrome.runtime.onMessage listener (do not create a second listener):

```
case 'GET_MATCH_STATUS':
  1. Read matchWebhookUrl from chrome.storage.local
  2. If not set, fall back to (webhookUrl + '/match') — also read webhookUrl from storage in same .get() call
  3. If neither is available, return { success: false, error: 'no match URL configured', statuses: {} }
  4. POST to matchWebhookUrl: fetch(matchWebhookUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ job_ids: message.jobIds }) })
  5. If fetch fails or response not ok: catch error, console.warn("GET_MATCH_STATUS failed:", err), return { success: false, error: err.message, statuses: {} }
  6. Parse response JSON as statusMap (object mapping job ID string to status string)
  7. Return { success: true, statuses: statusMap }
  8. This handler must return true from onMessage to signal async response (use sendResponse callback pattern or return a Promise — use the Promise pattern: return Promise pattern with async handler)
```

Message handler MUST use the sendResponse callback correctly for async: declare the listener as async, return true inside to keep the port open, or restructure as:
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'GET_MATCH_STATUS') {
    handleMatchStatus(message).then(sendResponse);
    return true; // keep port open
  }
  // ... other cases
});

**src/content/upwork-content.js — search page init:**

Add function initSearchPage():
1. Find all job cards in the DOM. Upwork search results: inspect live page to find the correct selector. Start with: document.querySelectorAll('[data-job-uid]') or querySelectorAll('article[data-test="job-tile"]') — find what works. Each card should have a link to the job. Extract job ID from the href attribute of the job title anchor using regex: href.match(/jobs\/~([a-z0-9]+)/i)?.[1]
2. Collect array of job IDs (skip any that failed to parse)
3. If no job IDs found: log "upwork-ext: no job IDs found on search page" and return
4. Send message: chrome.runtime.sendMessage({ action: 'GET_MATCH_STATUS', jobIds: jobIds }, (response) => { ... })
5. In callback: if chrome.runtime.lastError or !response?.success: log the error and return
6. For each jobId in response.statuses:
   a. Find the card element that corresponds to this jobId (match by href containing the jobId)
   b. Find the title link element within that card
   c. If an element with class 'upwork-ext-status-icon' already exists next to it: skip (already injected)
   d. Create span: const icon = document.createElement('span'); icon.className = 'upwork-ext-status-icon';
   e. Apply inline styles based on status: match=#22c55e, no_match=#ef4444, applied=#3b82f6, anything else=skip
   f. Set common styles: icon.style.cssText = 'border-radius:50%;width:10px;height:10px;display:inline-block;margin-left:6px;vertical-align:middle;'
   g. icon.style.backgroundColor = colorForStatus;
   h. titleLink.insertAdjacentElement('afterend', icon)

Add SPA navigation detection:
```js
let lastPath = location.pathname;
const observer = new MutationObserver(() => {
  if (location.pathname !== lastPath) {
    lastPath = location.pathname;
    routePage(); // re-run the page router
  }
});
observer.observe(document.body, { childList: true, subtree: true });
```

routePage() checks: if URL matches /search or /jobs and contains search params -> initSearchPage(); if URL matches /jobs/~ (detail) -> initDetailPage();

Call routePage() on initial script load.
  </action>
  <verify>
1. Load extension in Chrome, navigate to an Upwork search results page (https://www.upwork.com/nx/search/jobs/)
2. Open DevTools console on the page
3. Confirm: "upwork-ext: no job IDs found" OR no error (if job IDs found)
4. Check service worker console: GET_MATCH_STATUS case present, no syntax errors
5. If n8n is not running: service worker returns { success: false, error: '...' } and no icons appear — this is correct behavior
6. Inspect DOM: no .upwork-ext-status-icon spans exist (correct when n8n not running)
  </verify>
  <done>Service worker handles GET_MATCH_STATUS (async, returns true to keep port open). Content script on search pages collects job IDs from DOM, sends GET_MATCH_STATUS, and injects colored circle icons based on response. No icons on n8n failure. SPA navigation handled via MutationObserver.</done>
</task>

<task type="auto">
  <name>Task 2: Detail page scrape button (INJC-02)</name>
  <files>src/content/upwork-content.js</files>
  <action>
Add function initDetailPage() to src/content/upwork-content.js:

1. Extract job ID from URL: const match = location.pathname.match(/\/jobs\/~([a-z0-9]+)/i); if (!match) return;
2. If button already exists (document.getElementById('upwork-ext-scrape-btn')): return (handles re-runs)
3. Import or call detail-scraper.js scrapeDetailPage() function to get job data. Since content scripts in the same manifest content_scripts list share the same page context, detail-scraper.js should already be injected. Call: const jobData = scrapeDetailPage(); (function name from Phase 2 — adjust to match actual Phase 2 export)
4. Create button:
   ```js
   const btn = document.createElement('button');
   btn.id = 'upwork-ext-scrape-btn';
   btn.textContent = 'Scrape Job';
   btn.style.cssText = 'background:#14a800;color:white;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;font-size:14px;margin-top:8px;display:block;';
   ```
5. Find injection point: try document.querySelector('h1') (job title), then insertAdjacentElement('afterend', btn). Fallback: document.body.prepend(btn) if no h1 found.
6. Button click handler:
   ```js
   btn.addEventListener('click', () => {
     const jobData = scrapeDetailPage(); // re-scrape on click for freshness
     if (!jobData) { console.warn('upwork-ext: detail scrape returned nothing'); return; }
     chrome.runtime.sendMessage({ action: 'PUSH_JOBS', jobs: [jobData] }, (response) => {
       if (chrome.runtime.lastError) { console.warn('upwork-ext: push failed', chrome.runtime.lastError); return; }
       btn.textContent = response?.success ? 'Sent!' : 'Failed';
       setTimeout(() => { btn.textContent = 'Scrape Job'; }, 2000); // reset after 2s
     });
   });
   ```
7. Inject the button into the page.

Note: scrapeDetailPage() is defined in detail-scraper.js (Phase 2). The manifest must declare both detail-scraper.js and upwork-content.js as content scripts for detail pages, with detail-scraper.js listed first so it loads before upwork-content.js. Verify the manifest content_scripts ordering — if upwork-content.js is listed before detail-scraper.js, swap them for detail page matches. Do not modify manifest.json in this task — note in SUMMARY.md if a manifest ordering fix is needed.
  </action>
  <verify>
1. Navigate to any Upwork job detail page (https://www.upwork.com/jobs/~...)
2. Confirm a green "Scrape Job" button appears near the job title
3. Click the button: button text changes to "Sent!" or "Failed" (depending on webhook config), then resets to "Scrape Job" after 2s
4. Check DevTools console: no errors from button injection
5. Check service worker console: PUSH_JOBS message received (if button clicked)
  </verify>
  <done>"Scrape Job" button appears on job detail pages, is injected only once per page load/navigation, sends PUSH_JOBS on click with data from detail-scraper.js, shows transient feedback ("Sent!"/"Failed") then resets.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Search page icon overlay (INJC-01): colored circle icons appear on job cards based on n8n match status.
    Detail page scrape button (INJC-02): green "Scrape Job" button injected near job title.
    SPA navigation handled via MutationObserver (icons/button re-inject on route change).
  </what-built>
  <how-to-verify>
    1. Load the extension in Chrome (chrome://extensions -> Load unpacked -> select project root)
    2. Navigate to https://www.upwork.com/nx/search/jobs/ (or any Upwork job search with results)
    3. Open DevTools -> Console: confirm no JS errors from upwork-content.js
    4. If n8n is running with the match endpoint: colored circles should appear next to each job title within ~2s of page load
    5. If n8n is not running: no circles appear, no console errors (only console.warn in service worker)
    6. Navigate to a job detail page by clicking a job title: confirm "Scrape Job" button appears near the page's h1 title
    7. Click "Scrape Job": button briefly shows "Sent!" or "Failed" then returns to "Scrape Job"
    8. Navigate back to search results (SPA navigation): confirm icons re-appear (or re-attempt) on the new URL, button gone from search page
  </how-to-verify>
  <resume-signal>Type "approved" if icons and button work as described, or describe any issues (wrong selector, missing icons, button not appearing, JS errors)</resume-signal>
</task>

</tasks>

<verification>
Manual end-to-end check:
- Extension loads with no errors in chrome://extensions
- Service worker starts with no errors (Inspect views -> service worker)
- Search page: job IDs extracted from DOM and GET_MATCH_STATUS sent (visible in service worker console)
- Detail page: "Scrape Job" button present and functional
- SPA navigation: both behaviors re-trigger correctly on route change
- With n8n down: graceful degradation (no icons, no crashes)
</verification>

<success_criteria>
- Colored icons (green/red/blue circles) inject next to job titles on search pages when n8n responds with match statuses (INJC-01)
- "Scrape Job" button appears on detail pages and sends PUSH_JOBS to service worker on click (INJC-02)
- No JS errors in content script or service worker console during normal operation
- n8n unavailability causes graceful degradation (no icons, console.warn only)
- Icons not duplicated on SPA re-navigation
</success_criteria>

<output>
After completion, create `.planning/phases/03-webhook-integration-search-overlay/03-02-SUMMARY.md` using the summary template. Include: DOM selectors actually used (they will differ from estimates — document the real ones), message round-trip contract for GET_MATCH_STATUS, any manifest ordering changes needed, SPA navigation approach documented.
</output>
