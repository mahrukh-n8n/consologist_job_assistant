---
phase: 03-webhook-integration-search-overlay
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/webhook-client.js
  - src/background/service-worker.js
autonomous: true

must_haves:
  truths:
    - "After a scrape, job objects are POSTed to the configured n8n webhook URL"
    - "If the webhook URL is not set or output mode is CSV-only, no POST is made"
    - "If n8n is unavailable, the service worker retries with exponential backoff and logs the error without crashing"
    - "The payload field names match the reference project exactly: job_id, title, url, description, budget, payment_type, skills, experience_level, project_duration, posted_date, proposals_count, client_payment_verified, client_location, client_rating, client_total_spent"
  artifacts:
    - path: "src/utils/webhook-client.js"
      provides: "WebhookClient — dispatchJob(url, jobData) with retry/backoff"
      exports: ["WebhookClient"]
    - path: "src/background/service-worker.js"
      provides: "Message handler for PUSH_JOBS action; reads settings, calls WebhookClient"
      contains: "PUSH_JOBS"
  key_links:
    - from: "src/background/service-worker.js"
      to: "src/utils/webhook-client.js"
      via: "import / importScripts"
      pattern: "WebhookClient"
    - from: "src/background/service-worker.js"
      to: "chrome.storage.local"
      via: "chrome.storage.local.get"
      pattern: "webhookUrl|outputMode"
---

<objective>
Build the webhook push module: a WebhookClient utility used by the service worker to POST scraped job data to the configured n8n URL with exponential backoff retries. Output mode is checked before any network call — webhook sends only happen when the user's output mode includes "webhook".

Purpose: Close WEHK-01. Without this, scraped data never leaves the browser.
Output: src/utils/webhook-client.js (JS port of WebhookUtility from global class registry) and updated src/background/service-worker.js with PUSH_JOBS message handler.
</objective>

<execution_context>
@C:/Users/Glorvax/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Glorvax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/PROJECT.md
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/ROADMAP.md
@C:/Users/Glorvax/Documents/upwork chrome extention/.planning/STATE.md

## Global class to port

WebhookUtility (Python, src: ~/.claude/classes/http/webhook-utility.py) — async POST with exponential backoff, errors logged not raised, fire-and-forget. Port to JS fetch API for MV3 service worker context.

## Field name contract (CRITICAL — case-sensitive)

Payload keys must exactly match reference project:
job_id, title, url, description, budget, payment_type, skills, experience_level, project_duration, posted_date, proposals_count, client_payment_verified, client_location, client_rating, client_total_spent

## Output mode values (from Phase 1 settings)

Stored in chrome.storage.local as `outputMode`. Values: "webhook" | "csv" | "both"
Webhook push fires when outputMode === "webhook" || outputMode === "both"

## MV3 service worker constraint

No ES module imports in service worker unless manifest declares "type": "module". Use importScripts() or inline the utility, or declare module type. Prefer keeping service worker as a module (type: module in manifest) for cleaner imports — check what Phase 1 established.
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebhookClient utility (JS port of WebhookUtility)</name>
  <files>src/utils/webhook-client.js</files>
  <action>
Create src/utils/webhook-client.js as a JS port of the global WebhookUtility class. Export a single class WebhookClient with one async method: dispatchJob(url, jobData).

Implementation rules:
- Use the Fetch API (not XMLHttpRequest, not axios — no bundler in MV3 extensions)
- 3 retry attempts with exponential backoff: attempt 1 = 0ms delay, attempt 2 = 1000ms, attempt 3 = 2000ms (multiply by attempt index)
- On each attempt: fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(jobData) })
- If fetch throws (network error) or response.ok is false: catch the error, log with console.warn("WebhookClient: attempt N failed: <message>"), wait backoff delay, try again
- After all 3 attempts fail: console.error("WebhookClient: all retries failed for job", jobData.job_id) — do NOT throw
- On success (response.ok): return true
- On exhausted retries: return false
- Method is async; dispatchJob is non-blocking (caller does not need to await, but can)
- The class is stateless — no constructor config needed, just instantiate with new WebhookClient()

Export as ES module: export class WebhookClient { ... }

Do NOT validate or transform field names inside this utility — that is the caller's responsibility. This utility sends whatever jobData object it receives.
  </action>
  <verify>
Manually inspect src/utils/webhook-client.js:
- dispatchJob method present and async
- 3 retry loop with exponential delay
- try/catch on fetch, console.warn per failed attempt, console.error after exhaustion
- No throw on failure
- export class WebhookClient present
  </verify>
  <done>WebhookClient class exists at src/utils/webhook-client.js with dispatchJob(url, jobData) implementing 3-attempt exponential backoff, errors logged not raised, exported as ES module.</done>
</task>

<task type="auto">
  <name>Task 2: PUSH_JOBS message handler in service worker</name>
  <files>src/background/service-worker.js</files>
  <action>
Add a PUSH_JOBS message handler to the existing service worker. The service worker already handles scraping coordination (Phase 2). Add to its chrome.runtime.onMessage listener (or create one if not yet present):

Handler logic for action === 'PUSH_JOBS':
1. Read settings from chrome.storage.local: { webhookUrl, outputMode }
2. If outputMode is 'csv' (not 'webhook' or 'both'): log "WebhookClient: skipping webhook push, outputMode is csv-only" and return { success: false, skipped: true }
3. If webhookUrl is falsy or empty string: log "WebhookClient: no webhook URL configured" and return { success: false, skipped: true }
4. jobs = message.jobs (array of job objects from content script or popup)
5. Import WebhookClient: since this is a module-type service worker, use: import { WebhookClient } from '../utils/webhook-client.js'  — place this import at the TOP of the file with other imports
6. Instantiate: const client = new WebhookClient()
7. Dispatch each job: iterate jobs array, call await client.dispatchJob(webhookUrl, job) for each, collect results
8. Return { success: true, sent: N, failed: M } where N = jobs dispatched successfully, M = failures

The message format arriving from content scripts or popup:
{ action: 'PUSH_JOBS', jobs: [ { job_id, title, url, ... } ] }

CRITICAL: Do not rename or transform any job object keys. The scraper (Phase 2) already produces the correct field names. The service worker passes jobs as-is to dispatchJob.

Handle the case where jobs is undefined or empty: return { success: false, error: 'no jobs provided' }

If the service worker already has a chrome.runtime.onMessage listener, add the PUSH_JOBS case inside the existing switch/if-else. Do not create a second onMessage listener.
  </action>
  <verify>
1. Open src/background/service-worker.js and confirm:
   - WebhookClient imported at top of file
   - PUSH_JOBS case present in message handler
   - chrome.storage.local.get reads webhookUrl and outputMode
   - outputMode guard: skips if 'csv'
   - webhookUrl guard: skips if falsy
   - Per-job dispatchJob call in loop
2. Load extension in Chrome (chrome://extensions, developer mode, load unpacked)
3. Check service worker console for any syntax errors (Inspect views -> service worker)
  </verify>
  <done>Service worker handles PUSH_JOBS messages: reads storage, guards on outputMode and webhookUrl, dispatches each job via WebhookClient, returns sent/failed counts. No second onMessage listener created.</done>
</task>

</tasks>

<verification>
With extension loaded in Chrome (developer mode):
1. Open any Upwork search page
2. Open the extension popup, trigger a scrape (from Phase 2)
3. In the service worker DevTools console (chrome://extensions -> Inspect views -> service worker): confirm no JS errors on startup
4. Send a test message from the console: chrome.runtime.sendMessage({ action: 'PUSH_JOBS', jobs: [{ job_id: 'test-01', title: 'Test', url: 'https://upwork.com', description: '', budget: '', payment_type: '', skills: [], experience_level: '', project_duration: '', posted_date: '', proposals_count: 0, client_payment_verified: false, client_location: '', client_rating: 0, client_total_spent: '' }] }, console.log)
5. With no webhook URL set: response should be { success: false, skipped: true }
6. Set a webhook URL in settings, send message again: should see fetch attempt in console (will fail/retry if n8n not running, log console.warn per attempt, console.error after exhaustion, return { success: true, sent: 0, failed: 1 } or similar)
</verification>

<success_criteria>
- WebhookClient.dispatchJob() retries 3 times with exponential backoff and never throws
- PUSH_JOBS handler respects outputMode (skips if csv-only) and webhookUrl (skips if not configured)
- All job field names pass through untouched (job_id, title, url, description, budget, payment_type, skills, experience_level, project_duration, posted_date, proposals_count, client_payment_verified, client_location, client_rating, client_total_spent)
- Service worker loads without errors in chrome://extensions
</success_criteria>

<output>
After completion, create `.planning/phases/03-webhook-integration-search-overlay/03-01-SUMMARY.md` using the summary template. Include: files created/modified, WebhookClient retry logic documented, PUSH_JOBS message contract documented (input shape, output shape), any deviations from plan.
</output>
