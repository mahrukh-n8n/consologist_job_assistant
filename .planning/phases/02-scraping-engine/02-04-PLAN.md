---
phase: 02-scraping-engine
plan: "04"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/popup/popup.html
  - src/popup/popup.js
  - src/content/upwork-content.js
autonomous: true
gap_closure: true
requirements:
  - SCRP-02
  - SCRP-03

must_haves:
  truths:
    - "User opens popup on a search results page, clicks 'Scrape Now', and sees a count of scraped jobs (e.g. 'Scraped 10 jobs') or an error message"
    - "scrapeDetailPage() is reachable at runtime — a message with action 'scrapeDetail' sent to the content script returns { job: {...} } with all 15 fields"
    - "The scrape button is distinct from Save Settings and does not interfere with existing settings save behavior"
  artifacts:
    - path: "src/popup/popup.html"
      provides: "Scrape Now button element with id='scrape-btn' and a status area for feedback"
      contains: "scrape-btn"
    - path: "src/popup/popup.js"
      provides: "Click handler that queries the active tab and sends chrome.tabs.sendMessage with action 'scrapeSearch'"
      contains: "scrapeSearch"
    - path: "src/content/upwork-content.js"
      provides: "Import of scrapeDetailPage and message handler for action 'scrapeDetail'"
      contains: "scrapeDetailPage"
  key_links:
    - from: "src/popup/popup.js"
      to: "src/content/upwork-content.js"
      via: "chrome.tabs.sendMessage({ action: 'scrapeSearch' })"
      pattern: "sendMessage.*scrapeSearch"
    - from: "src/content/upwork-content.js"
      to: "src/content/detail-scraper.js"
      via: "import { scrapeDetailPage }"
      pattern: "import.*scrapeDetailPage.*detail-scraper"
    - from: "chrome.runtime.onMessage handler in upwork-content.js"
      to: "scrapeDetailPage()"
      via: "message.action === 'scrapeDetail'"
      pattern: "action.*scrapeDetail"
---

<objective>
Wire the two orphaned scraping features — the on-demand popup trigger (SCRP-03) and the detail page scraper (SCRP-02) — into the running extension.

Purpose: Both the search scraper and detail scraper are fully implemented but unreachable. This plan adds the missing UI entry point (popup scrape button) and the missing content script wiring (import + message handler for detail scraping). After this plan, all four Phase 2 requirements are satisfied.
Output: A popup scrape button that returns job count feedback, and a wired detail scraper reachable via message from any extension component.
</objective>

<execution_context>
@C:/Users/Glorvax/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Glorvax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/popup/popup.html
@src/popup/popup.js
@src/content/upwork-content.js
@src/content/detail-scraper.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Scrape Now button to popup</name>
  <files>src/popup/popup.html, src/popup/popup.js</files>
  <action>
In `src/popup/popup.html`:

Add a "Scrape Now" section above the `<footer>` block (before the closing `</main>` tag). The section should use the existing `.setting-group` class pattern for consistent styling:

```html
<!-- SCRP-03: On-demand scrape trigger -->
<section class="setting-group">
  <button id="scrape-btn" type="button">Scrape Now</button>
  <div id="scrape-status" class="save-status" aria-live="polite"></div>
</section>
```

Do NOT add the button inside `<footer>` — keep it in `<main>` so it is visually grouped with settings, not conflated with Save Settings. The existing `<footer>` block and its `#save-status` div remain unchanged.

In `src/popup/popup.js`:

1. Add two new DOM refs to the `els` object (after the existing `saveStatus` entry):
```js
scrapeBtn:    () => document.getElementById('scrape-btn'),
scrapeStatus: () => document.getElementById('scrape-status'),
```

2. Add a `showScrapeStatus(message, isError)` function mirroring the existing `showStatus()` pattern — same 2500ms auto-clear, uses `els.scrapeStatus()`, same class toggle logic. This keeps error display consistent.

3. Add a `triggerScrape()` async function:
```js
async function triggerScrape() {
  try {
    // Query the active tab in the current window
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tab) {
      showScrapeStatus('No active tab found', true);
      return;
    }
    // Send scrapeSearch to the content script on the active tab
    const response = await chrome.tabs.sendMessage(tab.id, { action: 'scrapeSearch' });
    if (response && Array.isArray(response.jobs)) {
      showScrapeStatus(`Scraped ${response.jobs.length} job${response.jobs.length !== 1 ? 's' : ''}`);
    } else {
      showScrapeStatus('Scrape returned no data', true);
    }
  } catch (err) {
    // Safe-fail: content script may not be injected on non-Upwork tabs
    console.error('[Popup] Scrape failed:', err);
    showScrapeStatus('Scrape failed — open an Upwork search page', true);
  }
}
```

4. In the `DOMContentLoaded` event listener block, bind the scrape button after the existing save button binding:
```js
els.scrapeBtn().addEventListener('click', triggerScrape);
```

Do NOT modify `saveSettings()`, `loadSettings()`, or the existing `#save-btn` binding. The scrape button is purely additive.
  </action>
  <verify>
Open `src/popup/popup.html` and confirm `id="scrape-btn"` and `id="scrape-status"` exist.
Open `src/popup/popup.js` and confirm:
- `scrapeBtn` and `scrapeStatus` entries exist in `els`
- `triggerScrape` function exists and contains `chrome.tabs.query` and `chrome.tabs.sendMessage`
- `showScrapeStatus` function exists
- `els.scrapeBtn().addEventListener('click', triggerScrape)` is in the DOMContentLoaded block
Run: `grep -n "scrape-btn\|scrapeBtn\|triggerScrape\|scrapeSearch" src/popup/popup.html src/popup/popup.js`
All four terms should appear.
  </verify>
  <done>
popup.html contains a button with id="scrape-btn" and a div with id="scrape-status".
popup.js contains triggerScrape() which sends { action: 'scrapeSearch' } to the active tab and displays job count or error in #scrape-status.
Existing Save Settings functionality is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire detail scraper into content script</name>
  <files>src/content/upwork-content.js</files>
  <action>
In `src/content/upwork-content.js`:

1. Add the missing import at the top of the file, immediately after the existing `scrapeSearchPage` import:
```js
import { scrapeDetailPage } from './detail-scraper.js';
```

The file currently reads:
```js
import { scrapeSearchPage } from './search-scraper.js';
```
After the change it should read:
```js
import { scrapeSearchPage } from './search-scraper.js';
import { scrapeDetailPage } from './detail-scraper.js';
```

2. Add a new `scrapeDetail` message handler inside the existing `chrome.runtime.onMessage.addListener` callback, immediately after the existing `scrapeSearch` block and before the final `return false`. Follow the exact same pattern as the `scrapeSearch` handler:

```js
// Triggered by popup or service worker to scrape the current job detail page
if (message.action === 'scrapeDetail') {
  const job = scrapeDetailPage();
  sendResponse({ job });
  return true;
}
```

The final shape of the message listener should be:
```js
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('[Content] Message received:', message.action || message.type);

  if (message.type === 'PING') {
    sendResponse({ status: 'ok', url: window.location.href });
    return true;
  }

  if (message.action === 'scrapeSearch') {
    const jobs = scrapeSearchPage();
    sendResponse({ jobs });
    return true;
  }

  if (message.action === 'scrapeDetail') {
    const job = scrapeDetailPage();
    sendResponse({ job });
    return true;
  }

  return false;
});
```

Do NOT change the PING handler, the scrapeSearch handler, or the console.log. Only add the import line and the new handler block.
  </action>
  <verify>
Run: `grep -n "scrapeDetailPage\|scrapeDetail\|detail-scraper" src/content/upwork-content.js`
Expected output:
- Line with `import { scrapeDetailPage } from './detail-scraper.js'`
- Line with `message.action === 'scrapeDetail'`
- Line with `const job = scrapeDetailPage()`
- Line with `sendResponse({ job })`

Confirm the file still contains the unchanged scrapeSearch handler and PING handler by checking line count has grown by ~5 lines from the original 27 lines.
  </verify>
  <done>
upwork-content.js imports scrapeDetailPage from ./detail-scraper.js.
A message handler for action 'scrapeDetail' calls scrapeDetailPage() and returns { job } via sendResponse.
The existing scrapeSearch and PING handlers are unchanged.
scrapeDetailPage() is now reachable at runtime via chrome.tabs.sendMessage or chrome.runtime.sendMessage with { action: 'scrapeDetail' }.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Static check — imports and handlers present:
   `grep -n "scrapeDetailPage\|scrapeDetail\|detail-scraper" src/content/upwork-content.js` — must return 4+ lines
   `grep -n "scrape-btn\|triggerScrape\|scrapeSearch" src/popup/popup.html src/popup/popup.js` — must return results in both files

2. No regressions — existing code untouched:
   `grep -n "scrapeSearch\|PING\|saveSettings" src/content/upwork-content.js src/popup/popup.js` — all three must still appear

3. Load the extension in Chrome (chrome://extensions, Load unpacked). Open popup — the "Scrape Now" button should be visible below the notification settings and above the Save Settings footer.

4. Navigate to an Upwork search results page. Click "Scrape Now" in the popup. The scrape-status area should display "Scraped N jobs" (or "Scraped 0 jobs" if no job cards found). No error should appear unless the content script is not injected.

5. Human verification (recorded in SUMMARY): Navigate to a job detail page. In the service worker DevTools inspector, run:
   `chrome.tabs.query({active: true, currentWindow: true}, ([tab]) => chrome.tabs.sendMessage(tab.id, {action: 'scrapeDetail'}, (r) => console.log(r)))`
   Response should contain `{ job: { job_id: "...", title: "...", ... } }` with 15 keys.
</verification>

<success_criteria>
- SCRP-03 satisfied: popup.html has a "Scrape Now" button; clicking it on a search page returns job count feedback via sendMessage to the content script
- SCRP-02 satisfied: upwork-content.js imports and exposes scrapeDetailPage() via the 'scrapeDetail' message action — detail scraper is no longer orphaned
- Gap 1 (popup trigger) closed: popup.html has #scrape-btn; popup.js has triggerScrape() sending { action: 'scrapeSearch' }
- Gap 2 (detail scraper orphaned) closed: upwork-content.js has import { scrapeDetailPage } and the 'scrapeDetail' message handler
- All existing handlers (PING, scrapeSearch, saveSettings) unchanged
- Phase 2 all four requirements (SCRP-01, SCRP-02, SCRP-03, SCRP-04) are now satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-scraping-engine/02-04-SUMMARY.md`
</output>
