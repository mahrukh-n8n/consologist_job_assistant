---
phase: 02-scraping-engine
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
files_modified:
  - src/background/service-worker.js
autonomous: true

must_haves:
  truths:
    - "After the popup saves a scrape interval, the extension automatically scrapes Upwork search results at that interval without any popup interaction"
    - "chrome.alarms fires at the configured interval and the service worker executes a scrape cycle"
    - "If no Upwork search tab is open, the service worker opens one, scrapes, then closes it"
    - "If an Upwork search tab is already open, the service worker reuses it and does not open a duplicate"
    - "The alarm resets correctly when the user changes the interval in settings"
  artifacts:
    - path: "src/background/service-worker.js"
      provides: "Alarm registration, alarm listener, tab management, and scrape orchestration logic"
      contains: ["chrome.alarms.create", "chrome.alarms.onAlarm", "chrome.tabs.query", "chrome.storage.local.get"]
  key_links:
    - from: "src/background/service-worker.js"
      to: "src/content/search-scraper.js"
      via: "chrome.tabs.sendMessage to trigger scrapeSearchPage()"
      pattern: "sendMessage.*scrapeSearch"
    - from: "src/popup/popup.js"
      to: "src/background/service-worker.js"
      via: "chrome.runtime.sendMessage with action: 'updateAlarm'"
      pattern: "updateAlarm"
---

<objective>
Wire chrome.alarms into the service worker so the extension automatically runs scrape cycles at the interval the user configured in Phase 1 settings.

Purpose: Requirement SCRP-04 — scheduled scraping must happen without user interaction. This plan connects the settings the user saved in Phase 1 to the scrapers built in Plans 02-01 and 02-02.
Output: Updated src/background/service-worker.js with alarm registration and scrape orchestration
</objective>

<execution_context>
@C:/Users/Glorvax/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Glorvax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-scraping-engine/02-01-SUMMARY.md
@.planning/phases/02-scraping-engine/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Alarm registration and interval management</name>
  <files>src/background/service-worker.js</files>
  <action>
Add alarm management to the service worker. The service worker already exists from Phase 1 (or create it if missing). Add the following logic — do not remove existing message handlers.

**Constants at top of file:**
```js
const ALARM_NAME = 'upwork-scrape-alarm';
const DEFAULT_INTERVAL_MINUTES = 30;
```

**On service worker install/startup — register alarm from stored interval:**
```js
chrome.runtime.onInstalled.addListener(registerAlarmFromStorage);
chrome.runtime.onStartup.addListener(registerAlarmFromStorage);

async function registerAlarmFromStorage() {
  const { scrapeInterval } = await chrome.storage.local.get({ scrapeInterval: DEFAULT_INTERVAL_MINUTES });
  await chrome.alarms.clear(ALARM_NAME);
  chrome.alarms.create(ALARM_NAME, {
    delayInMinutes: scrapeInterval,
    periodInMinutes: scrapeInterval,
  });
  console.debug('[upwork-ext] alarm registered:', scrapeInterval, 'min');
}
```

**Message handler for popup "updateAlarm" — fires when user changes interval in settings:**
Add inside the existing `chrome.runtime.onMessage.addListener` callback (or create one if absent):
```js
if (message.action === 'updateAlarm') {
  const intervalMinutes = message.intervalMinutes || DEFAULT_INTERVAL_MINUTES;
  await chrome.alarms.clear(ALARM_NAME);
  chrome.alarms.create(ALARM_NAME, {
    delayInMinutes: intervalMinutes,
    periodInMinutes: intervalMinutes,
  });
  sendResponse({ success: true });
  return true; // keep channel open for async
}
```

**Wire popup save to send updateAlarm message (add to src/popup/popup.js if not already present):**
When the user saves their interval setting, popup.js should send:
```js
chrome.runtime.sendMessage({
  action: 'updateAlarm',
  intervalMinutes: parseInt(intervalValue, 10),
});
```
Add this to the save handler in popup.js. Do not overwrite other save logic.
  </action>
  <verify>Open chrome://extensions, load the extension unpacked, open chrome://extensions -> service worker inspect. Run `chrome.alarms.getAll(console.log)` in the service worker console. Confirm one alarm named 'upwork-scrape-alarm' appears with the correct periodInMinutes.</verify>
  <done>chrome.alarms.getAll() returns an alarm named 'upwork-scrape-alarm' with periodInMinutes matching the stored scrapeInterval. Changing interval in popup and saving re-registers alarm with new period.</done>
</task>

<task type="auto">
  <name>Task 2: Alarm listener with tab management and scrape orchestration</name>
  <files>src/background/service-worker.js</files>
  <action>
Add the alarm listener that fires when the alarm triggers. This handles finding or opening an Upwork search tab and sending a scrape message to the content script.

**Alarm listener:**
```js
chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name !== ALARM_NAME) return;
  console.debug('[upwork-ext] alarm fired — starting scrape cycle');
  await runScheduledScrape();
});
```

**runScheduledScrape function:**
```js
async function runScheduledScrape() {
  // Find an existing Upwork search tab
  const tabs = await chrome.tabs.query({ url: 'https://www.upwork.com/nx/search/jobs/*' });

  let tabId;
  let opened = false;

  if (tabs.length > 0) {
    tabId = tabs[0].id;
  } else {
    // No search tab open — open one
    const tab = await chrome.tabs.create({
      url: 'https://www.upwork.com/nx/search/jobs/',
      active: false, // open in background
    });
    tabId = tab.id;
    opened = true;

    // Wait for the tab to finish loading
    await waitForTabLoad(tabId);
  }

  // Send scrape command to the content script in that tab
  let jobs = [];
  try {
    const response = await chrome.tabs.sendMessage(tabId, { action: 'scrapeSearch' });
    jobs = response?.jobs || [];
    console.debug('[upwork-ext] scheduled scrape complete:', jobs.length, 'jobs');
  } catch (err) {
    console.error('[upwork-ext] scrape message failed:', err);
  }

  // Close the tab if we opened it
  if (opened) {
    await chrome.tabs.remove(tabId);
  }

  // Store results for popup display and downstream phases
  if (jobs.length > 0) {
    await chrome.storage.local.set({
      lastScrapeJobs: jobs,
      lastScrapeTime: new Date().toISOString(),
    });
  }
}
```

**waitForTabLoad helper:**
```js
function waitForTabLoad(tabId) {
  return new Promise((resolve) => {
    function listener(id, changeInfo) {
      if (id === tabId && changeInfo.status === 'complete') {
        chrome.tabs.onUpdated.removeListener(listener);
        // Extra delay for JS-rendered content
        setTimeout(resolve, 2000);
      }
    }
    chrome.tabs.onUpdated.addListener(listener);
  });
}
```

**Content script message handler — add to upwork-content.js:**
The content script must listen for the 'scrapeSearch' action and return results:
```js
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'scrapeSearch') {
    const jobs = scrapeSearchPage();
    sendResponse({ jobs });
    return true;
  }
});
```
This listener should be added to src/content/upwork-content.js. Import scrapeSearchPage at the top of upwork-content.js if not already imported.
  </action>
  <verify>In the service worker console (chrome://extensions -> inspect service worker): run `runScheduledScrape()` manually. Confirm: (1) if a search tab exists it is reused (check tabs before/after), (2) if no search tab exists one opens, scrapes, and closes, (3) chrome.storage.local.get(['lastScrapeJobs']) returns an array of job objects after the call completes.</verify>
  <done>runScheduledScrape() executes without errors, reuses existing Upwork search tabs or opens/closes a background tab, stores results in chrome.storage.local under lastScrapeJobs and lastScrapeTime. The alarm listener fires runScheduledScrape when the alarm triggers.</done>
</task>

</tasks>

<verification>
1. Install extension unpacked in Chrome
2. Open settings popup, set interval to 1 minute, save
3. Inspect service worker console: confirm alarm 'upwork-scrape-alarm' shows with periodInMinutes: 1
4. Wait approximately 1 minute
5. In service worker console, run: `chrome.storage.local.get(['lastScrapeJobs', 'lastScrapeTime'], console.log)`
6. Confirm lastScrapeJobs is an array of job objects and lastScrapeTime is a recent ISO timestamp
7. Change interval to 2 minutes in popup, save, confirm alarm updates: `chrome.alarms.getAll(console.log)` shows periodInMinutes: 2
8. Confirm no duplicate alarms exist
</verification>

<success_criteria>
- chrome.alarms alarm named 'upwork-scrape-alarm' is registered on install and startup
- Alarm period matches the scrapeInterval stored in chrome.storage.local
- Changing interval in popup re-registers alarm with new period (no duplicates)
- Alarm listener calls runScheduledScrape() on each fire
- runScheduledScrape reuses existing Upwork search tabs, opens background tab only when none exists
- Opened tabs are closed after scrape completes
- Scrape results stored in chrome.storage.local as lastScrapeJobs (array) and lastScrapeTime (ISO string)
- No unhandled promise rejections in service worker console during a full scrape cycle
</success_criteria>

<output>
After completion, create `.planning/phases/02-scraping-engine/02-03-SUMMARY.md` following the summary template.
</output>
